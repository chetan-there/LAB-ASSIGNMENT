Q1)
class Test extends Thread {
    public void run() {
        for(int i=0; i<=10; i++) {
            System.out.println("Hello Welcome here.."+i);
        }
    }
}
class Test1 {
    public static void main(String[] args) {
        Test t = new Test();
        t.start();
        t.start();
    }
}
Output:
Runtime Exception: IllegalThreadStateException
Explanation: You cannot start a thread more than once. The second call to t.start() throws IllegalThreadStateException.
________________________________________
Q2)
class Test {
    public static void main(String []args) {
        Thread t = Thread.currentThread();
        System.out.println(t);
        System.out.println("Name of thread  : "+t.getName());
        System.out.println("Id of thread  : "+t.getId());
    } 
}
Output (may vary):
Thread[main,5,main]
Name of thread  : main
Id of thread  : 1
Explanation: This code displays details of the main thread.
________________________________________
Q3)
class Test {
    public static void main(String args[]) {
        new Thread() {
            public void run() {
                System.out.println("task one");
            }
        }.start();

        new Thread() {
            public void run() {
                System.out.println("task two");
            }
        }.start();
    }
}
Output:
task one
task two
(Order may vary) Explanation: Two anonymous threads are created and started. They print messages.
________________________________________
Q4)
class Test {
    public static void main(String args[]) {
        Runnable r1 = new Runnable() {
            public void run() {
                System.out.println("task one");
            }
        };

        Runnable r2 = new Runnable() {
            public void run() {
                System.out.println("task two");
            }
        };

        Thread t1 = new Thread(r1);
        Thread t2 = new Thread(r2);

        t1.start();
        t2.start();
    }
}
Output:
task one
task two
(Order may vary) Explanation: Two Runnable objects passed to two threads. Both start and execute their tasks.
________________________________________
Q5)
class SimpleThread extends Thread {
    public SimpleThread(String str) {
        super(str);
    }
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(i + " " + getName());
            try {
                sleep((int)(Math.random() * 1000));
            } catch (InterruptedException e) {}
        }
        System.out.println("DONE! " + getName());
    }
}
class Test {
    public static void main (String args[]) {
        new SimpleThread("J2EE").start();
        new SimpleThread("J2ME").start();
    }
}
Output:
Interleaved numbers from both threads with names, ending in DONE! J2EE / J2ME
Explanation: Two threads print their index and name, then finish.
________________________________________
Q6)
class Prime extends Thread {
    public void run() {
        try {
            for(int i=1;i<=10;i++) {
                if(i==2||i==3||i==5||i==7) {
                    System.out.println ("Prime No.= "+i);
                }
                Thread.sleep(500);
            }
        } catch (Exception e){}
    }
}
class NotPrime extends Thread {
    public void run() {
        try {
            for(int i=1;i<=10;i++) {
                if(i==4||i==6||i==8||i==9||i==10) {
                    System.out.println ("Non-Prime No.= "+i);
                }
                Thread.sleep(500);
            }
        } catch (Exception e){}
    }
}
class Test {
    public static void main(String args[]) {
        new Prime().start();
        new NotPrime().start();
    }
}
Output:
Prime and Non-Prime numbers interleaved (timing may differ)
Explanation: Both threads print prime and non-prime numbers with sleep to simulate delay.
________________________________________
Q7)
public class Test21 extends Thread {
    static Thread t;
    public static void main(String [] args) {
        try {
            t=new Thread(new Test21(),"Ravi");
            t.start();
        } catch (Exception e) {
            System.out.println(e);
        }
    }
    public void run() {
        for(int i=1; i<5; i++) {
            try {
                System.out.print(Thread.currentThread().getName()+" ");
                t.start();
            } catch (Exception e) {
                System.out.println(" will not botther about but "+e+" happened "+i+" times");
            }
        }
    }
}
Output:
Ravi  will not botther about but java.lang.IllegalThreadStateException happened 1 times
Ravi  will not botther about but java.lang.IllegalThreadStateException happened 2 times
...
Explanation: Trying to start the same thread again in the run method leads to IllegalThreadStateException.
Here is the continuation from Q8 onwards with multithreading Java output questions, expected output, and explanations:
________________________________________
Q8)
class MyThread extends Thread {
    public void run() {
        System.out.println("run method called");
    }
}
class Test {
    public static void main(String args[]) {
        MyThread t1 = new MyThread();
        Thread t2 = new Thread(t1);
        t1.start();
        t2.start();
    }
}
Output:
run method called  
run method called
Explanation:
Both t1 (a Thread) and t2 (a Thread wrapping another Thread) are started. Both invoke the same run() method.
________________________________________
Q9)
class Test {
    public static void main(String args[]) {
        Thread t = new Thread(new Runnable() {
            public void run() {
                System.out.println("Runnable run");
            }
        }) {
            public void run() {
                System.out.println("Thread run");
            }
        };
        t.start();
    }
}
Output:
Thread run
Explanation:
If both Runnable and Thread define run(), then Thread's run() overrides Runnable's one.
________________________________________
Q10)
class Test {
    public static void main(String args[]) throws InterruptedException {
        Thread t = new Thread(() -> {
            System.out.println("Inside thread");
        });
        t.start();
        t.join();
        System.out.println("Main thread after join");
    }
}
Output:
Inside thread  
Main thread after join
Explanation:
join() makes the main thread wait for t to finish execution before proceeding.
________________________________________
Q11)
class Test {
    public static void main(String args[]) {
        Thread t = new Thread(() -> {
            try {
                Thread.sleep(1000);
                System.out.println("Child thread");
            } catch (InterruptedException e) {
                System.out.println("Interrupted");
            }
        });

        t.start();
        t.interrupt();
    }
}
Output:
Interrupted
Explanation:
Thread t is interrupted while sleeping, which throws InterruptedException.
________________________________________
Q12)
class Test {
    public static void main(String[] args) {
        Thread t = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                System.out.println("Running...");
            }
            System.out.println("Stopped...");
        });
        t.start();
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {}
        t.interrupt();
    }
}
Output:
Running... (printed many times)  
Stopped...
Explanation:
Thread runs until it's interrupted. Then exits the loop and prints "Stopped...".
Perfect! Here's the continuation from Q13 to Q20 with formatted Java multithreading questions, expected output, and explanations:
________________________________________
Q13)
class Test58 
{
    public static void main(String[] args) 
    {
        
    }
    System.out.println("Hello World!");
}
Output:
Compilation Error
Explanation:
You cannot write executable statements like System.out.println() outside of a method or static/instance block. It violates Java syntax rules.
________________________________________
Q14)
class Test61
{
    public static void main(String[] args) 
    {
        Runnable r1 = new Runnable() {
            public void run() {
                try {
                    while (true) {
                        System.out.println("Hello, world!");
                        Thread.sleep(1000);
                    }
                } catch (InterruptedException iex) {}
            }
        };

        Runnable r2 = new Runnable() {
            public void run() {
                try {
                    while (true) {
                        System.out.println("Goodbye, Beautiful world!");
                        Thread.sleep(2000);
                    }
                } catch (InterruptedException iex) {}
            }
        };

        Thread thr1 = new Thread(r1);
        Thread thr2 = new Thread(r2);
        thr1.start();
        thr2.start();
    }
}
Output (infinite loop):
Hello, world!
Goodbye, Beautiful world!
Hello, world!
Hello, world!
Goodbye, Beautiful world!
...
Explanation:
Two threads run infinitely: one prints every 1s and the other every 2s. You'll see interleaved output.
________________________________________
Q15)
class Test4
{
    public static void main(String []argv)
    {
        Thread t = Thread.currentThread();
        System.out.println("Name of current thread : " + t.getName());
        t.setName("First Thread");
        System.out.println("Name of thread after change : " + t.getName());
    } 
}
Output:
Name of current thread : main
Name of thread after change : First Thread
Explanation:
The main thread's name is changed to "First Thread" using setName() method.
________________________________________
Q16)
class Test15 extends Thread
{
    public void run()
    {
        System.out.println("PRINT ME");
    }
    public static void main(String []str)
    {
        try {
            for(int i=0; i<9; i++) {
                System.out.println(i);
                Thread.sleep(500);
            }
        } catch(InterruptedException e) {
            System.out.println("thread exception");
        }
        Thread t = new Thread();
        t.start();
    }
}
Output:
0  
1  
2  
3  
4  
5  
6  
7  
8  
Exception in thread "main" java.lang.IllegalThreadStateException
Explanation:
You created a thread with no runnable target, and since Thread.run() is empty by default, it runs nothing. But it throws exception when thread is not properly initialized (OS dependent behavior).
________________________________________
Q17)
class Foo implements Runnable
{
    public void run() 
    {
        for(int i=0;i<3;i++)
            System.out.println("Run by..."+Thread.currentThread().getName()+", i is "+ i);
    }

    public void run(String name)
    {
        System.out.println("This is Second " + name);
    }
}

public class Test18
{
    public static void main(String args[])
    {
        Foo f = new Foo();
        Thread t = new Thread(f);
        try 
        {
            System.out.println("Number will be printed after 500 milliseconds...");
            for(int j=0;j<5;j++)
            {
                System.out.println("This is j..."+j);
                Thread.sleep(500);
            }
        }
        catch(InterruptedException e) 
        {
            System.out.println("InterruptedException.."+ e);
        }
    }
}
Output:
Number will be printed after 500 milliseconds...
This is j...0
This is j...1
This is j...2
This is j...3
This is j...4
Explanation:
Thread t is never started, so run() is not executed. Only the loop with j runs. The overloaded run(String) is not a thread method and won’t be invoked.
________________________________________
Q18)
public class Test28 extends Thread
{
    public static void main(String [] args)
    {
        System.out.println(Thread.currentThread().getId()+" ");
        Thread t1 = new Thread(new Test28(),"Rahul");
        Thread t2 = new Thread(new Test28(),"Ravi");
        Thread t3 = new Thread(new Test28(),"Puja");
        t3.start();
        t1.start();
        t2.run();  // This runs on main thread
        t2.start(); // t2 started again (Illegal)
    }

    public  void run()
    {
        for(int i=0; i<2; i++)
            System.out.println(Thread.currentThread().getName()+" I'm :"+i);
        System.out.println("It is end of loop");
    }
}
Output:
<Main thread ID>
Ravi I'm :0  
Ravi I'm :1  
It is end of loop  
...
Exception in thread "main" java.lang.IllegalThreadStateException
Explanation:
t2.run() runs in main thread. But t2.start() is called after run() which means the thread was already started. Starting a thread twice causes IllegalThreadStateException.
________________________________________
Q19)
class MyThread extends Thread 
{
    public void run() 
    {
        for (int i=0; i < 10; i++) 
        {
            System.out.println("hello world1");
        }
    }
}

public class Test36
{
    public static void main(String [] args) 
    {
        MyThread t1 = new MyThread();
        t1.start();
        try 
        {
            t1.join(); 
        } 
        catch (InterruptedException e) 
        {
            System.out.println("ERROR: Thread was interrupted");
        }       
        System.out.println("Thread is done!");
    }
}
Output:
hello world1  
hello world1  
... (10 times)
Thread is done!
Explanation:
Main thread waits for t1 to complete using join(). After t1 finishes, it prints "Thread is done!"
________________________________________
Q20)
public class JoinDemo1 
{
    public static void main(String[] args) throws InterruptedException 
    {
        System.out.println("Main thread started");
        Thread thread = Thread.currentThread();
        String name = thread.getName();
        
        for(int i=1; i<=5; i++)
        {           
            System.out.println(i + " by " + name + " thread ");
            Thread.sleep(1000);
            thread.join(); // Main thread joining itself
        }       
        System.out.println("Main thread ended");
    }
}
Output:
Main thread started  
1 by main thread  
Exception in thread "main" java.lang.IllegalThreadStateException
Explanation:
You cannot join() the current thread (i.e., the main thread waiting for itself). It causes deadlock and throws IllegalThreadStateException.

