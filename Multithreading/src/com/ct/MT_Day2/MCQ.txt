Let's solve each question one by one, providing the full question, the correct output, and a brief explanation below each.
________________________________________
Q1
public class Test45 extends Thread {
    static String sName = "good";
    public static void main(String argv[]) {
        Test45 t = new Test45();
        t.nameTest(sName);
        System.out.println(sName);    
    }

    public void nameTest(String sName) {
        sName = sName + " idea ";
        start();
    }

    public void run() {
        for(int i=0; i<4; i++) {
            sName = sName + " " + i;
        }
    }
}
Output:
good
Explanation:
•	sName inside nameTest is a local variable shadowing the static variable.
•	start() calls run() in a separate thread, but sName modified in run() is also local.
•	System.out.println(sName) in main() refers to the static variable, which remains unchanged.
________________________________________
Q2
public class Test46 {
    public static void main(String argv[]) {
        Test1 pm1 = new Test1("One");
        pm1.run();
        Test1 pm2 = new Test1("Two");
        pm2.run();
    }
}
class Test1 extends Thread {
    private String sTname = "";
    Test1(String s) {
        sTname = s;
    }
    public void run() {
        for(int i = 0; i < 5 ; i++) {
            try {
                sleep(1000);
            } catch(InterruptedException e) {}
            Thread.yield();
            System.out.println(sTname);
        }
    }
}
Output:
One
One
One
One
One
Two
Two
Two
Two
Two
Explanation:
•	run() is called directly, so no new thread is started.
•	It runs sequentially, first printing "One" 5 times, then "Two" 5 times.
________________________________________
Q3
class Test55 extends Thread {
    static Thread tf, ts;

    public synchronized void run() {
        System.out.println(Thread.currentThread().getName()+"");
        ts.start();
    }

    public static void main(String[] args) {
        tf = new Thread(new Test55(),"SCJP");
        ts = new Thread(new Test55(),"SCJWD");
        tf.start();
    }
}
Output:
SCJP
SCJWD
Explanation:
•	tf is started in main, which prints "SCJP" and calls ts.start() inside run(), leading to "SCJWD".
________________________________________
Q4
public class Test56 implements Runnable {
    public void run() {
        try {
            System.out.println("run.");
            throw new RuntimeException("Problem");
        } catch (Exception e) {
            System.out.println("Handled");
        }
    }
    public static void main(String[] args) {
        Thread t = new Thread(new Test56());
        t.start();
        System.out.println("End of method.");
    }
}
Output:
End of method.
run.
Handled
Explanation:
•	Main thread prints "End of method".
•	Child thread runs run() and handles the exception.
________________________________________
Q5
public class Test59 {
    public static void main(String [] args) {
        myRunnable r = new myRunnable();

        Thread t1 = new Thread();
        Thread t2 = new Thread();

        t1.setName("Thread One");
        t2.setName("Thread Two");

        t1.start();
        t2.start();

        System.out.println("Mains Thread: " + Thread.currentThread().getName());
    }
}

class myRunnable implements Runnable {
    public void run() {
        for ( int i = 1; i < 4; i++) 
            System.out.println("Thread: " + Thread.currentThread().getName());
    }
}
Output:
Mains Thread: main
Explanation:
•	The threads t1 and t2 don’t have the runnable attached, so their run() does nothing.
•	Only main prints its name.
Q6
class Test {
    public static void main(String[] args) {
        Thread t = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        });
        t.run();
        System.out.println("Main thread finished");
    }
}
Output:
main: 0
main: 1
main: 2
main: 3
main: 4
Main thread finished
Explanation:
•	t.run() runs the code in the main thread (not a new thread).
•	So all output shows main as the thread name.
________________________________________
Q7
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}

public class Test {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println(counter.getCount());
    }
}
Output:
2000
Explanation:
•	Both threads increment the same counter 1000 times.
•	increment() is synchronized, so result is consistent.
________________________________________
Q8
class Test {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            System.out.println("Thread-1 running");
        });

        t1.start();
        t1.join();
        t1.start();
    }
}
Output:
Thread-1 running
Exception in thread "main" java.lang.IllegalThreadStateException
Explanation:
•	You cannot start a thread twice.
•	Second t1.start() throws IllegalThreadStateException.
________________________________________
