✅ Q1
✅ Code:
class Task extends Thread {
    public void run() {
        synchronized (this) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Task Completed by :" + Thread.currentThread().getName());
        }
    }
}

public class Exam {
    public static void main(String[] args) throws InterruptedException {
        Task task1 = new Task();
        Task task2 = new Task();
        task1.start();
        task2.start();
        task1.join();
        task2.join();
    }
}
✅ Explanation:
•	Two threads task1 and task2 are started.
•	Both have their own synchronized (this) blocks, so they don’t block each other.
•	sleep(1000) adds delay but doesn't release the lock.
•	After delay, each thread prints its own message.
•	join() ensures the main thread waits for both to finish.
✅ Output:
Task Completed by :Thread-0
Task Completed by :Thread-1
(Note: Output order may vary)
________________________________________
✅ Q2
✅ Code:
class Exam {
    public static void main(String[] args) throws InterruptedException {
        final Object lock = new Object();

        Thread t1 = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("Waiting for Response");
                    lock.wait();
                } catch (InterruptedException e) {
                    System.out.println("Interrupted");
                }
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (lock) {
                lock.notify();
                System.out.println("Sending Notification");
            }
        });

        t1.start();
        t2.start();

        t1.join();
        t2.join();
        System.out.println("Completed");
    }
}
✅ Explanation:
•	t1 waits on lock and releases it.
•	t2 notifies lock, waking up t1.
•	Proper wait/notify coordination used on the same object.
•	join() ensures main waits for both threads.
✅ Output:
Waiting for Response
Sending Notification
Completed
(Note: Order of Sending Notification and Completed may vary slightly)
________________________________________
✅ Q3
✅ Code:
class Reentrant {
    public synchronized void m() {
        n();
        System.out.println("this is m() method");
    }

    public synchronized void n() {
        System.out.println("this is n() method");
    }
}

class Demo30 {
    public static void main(String args[]) {
        final Reentrant re = new Reentrant();
        Thread t1 = new Thread() {
            public void run() {
                re.m();
            }
        };
        t1.start();
    }
}
✅ Explanation:
•	m() is synchronized and calls another synchronized method n() of the same object.
•	Java allows reentrant locks, so the thread can re-enter the lock.
✅ Output:
this is n() method
this is m() method
________________________________________
