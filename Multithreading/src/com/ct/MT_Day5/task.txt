✅ Q1
✅ Code:
class Task extends Thread {
    public void run() {
        synchronized (this) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Task Completed by :" + Thread.currentThread().getName());
        }
    }
}

public class Exam {
    public static void main(String[] args) throws InterruptedException {
        Task task1 = new Task();
        Task task2 = new Task();
        task1.start();
        task2.start();
        task1.join();
        task2.join();
    }
}
✅ Explanation:
•	Two threads task1 and task2 are started.
•	Both have their own synchronized (this) blocks, so they don’t block each other.
•	sleep(1000) adds delay but doesn't release the lock.
•	After delay, each thread prints its own message.
•	join() ensures the main thread waits for both to finish.
✅ Output:
Task Completed by :Thread-0
Task Completed by :Thread-1
(Note: Output order may vary)
________________________________________
✅ Q2
✅ Code:
class Exam {
    public static void main(String[] args) throws InterruptedException {
        final Object lock = new Object();

        Thread t1 = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("Waiting for Response");
                    lock.wait();
                } catch (InterruptedException e) {
                    System.out.println("Interrupted");
                }
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (lock) {
                lock.notify();
                System.out.println("Sending Notification");
            }
        });

        t1.start();
        t2.start();

        t1.join();
        t2.join();
        System.out.println("Completed");
    }
}
✅ Explanation:
•	t1 waits on lock and releases it.
•	t2 notifies lock, waking up t1.
•	Proper wait/notify coordination used on the same object.
•	join() ensures main waits for both threads.
✅ Output:
Waiting for Response
Sending Notification
Completed
(Note: Order of Sending Notification and Completed may vary slightly)
________________________________________
✅ Q3
✅ Code:
class Reentrant {
    public synchronized void m() {
        n();
        System.out.println("this is m() method");
    }

    public synchronized void n() {
        System.out.println("this is n() method");
    }
}

class Demo30 {
    public static void main(String args[]) {
        final Reentrant re = new Reentrant();
        Thread t1 = new Thread() {
            public void run() {
                re.m();
            }
        };
        t1.start();
    }
}
✅ Explanation:
•	m() is synchronized and calls another synchronized method n() of the same object.
•	Java allows reentrant locks, so the thread can re-enter the lock.
✅ Output:
this is n() method
this is m() method
________________________________________
✅ Q4
✅ Code:
class Tester {
    synchronized void hit(long n) {
        for (int i = 1; i < 3; i++)
            System.out.print(n + "-" + i + " ");
    }
}

public class Demo31 implements Runnable {
    static Tester pp2 = new Tester();

    public static void main(String[] args) {
        new Thread(new Demo31()).start();
        new Thread(new Demo31()).start();
    }

    public void run() {
        pp2.hit(Thread.currentThread().getId());
    }
}
✅ Explanation:
•	Two threads share a common object pp2.
•	hit() is synchronized, so only one thread accesses it at a time.
•	Output will be two separate sequences, one per thread.
✅ Output:
<Thread-ID>-1 <Thread-ID>-2 <Thread-ID>-1 <Thread-ID>-2 
(Actual thread IDs will vary)
________________________________________
✅ Q5
✅ Code:
class Pen {}
class Paper {}

public class demo35 {
    public static void main(String[] args) {
        final Pen pn = new Pen();
        final Paper pr = new Paper();

        Thread t1 = new Thread() {
            public void run() {
                synchronized (pn) {
                    System.out.println("Thread1 is holding Pen");
                    try { Thread.sleep(1000); } catch (InterruptedException e) {}
                    synchronized (pr) {
                        System.out.println("Requesting for Paper");
                    }
                }
            }
        };

        Thread t2 = new Thread() {
            public void run() {
                synchronized (pr) {
                    System.out.println("Thread2 is holding Paper");
                    try { Thread.sleep(1000); } catch (InterruptedException e) {}
                    synchronized (pn) {
                        System.out.println("requesting for Pen");
                    }
                }
            }
        };

        t1.start();
        t2.start();
    }
}
✅ Explanation:
•	Deadlock risk: t1 holds pn and waits for pr, while t2 holds pr and waits for pn.
•	May cause threads to wait forever.
✅ Output (Possible):
Thread1 is holding Pen
Thread2 is holding Paper
(May hang due to deadlock — no further output)
________________________________________
